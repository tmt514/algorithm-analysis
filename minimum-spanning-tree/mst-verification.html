<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>驗證最小生成樹 - 演算法的分析與證明</title>


        <!-- Custom HTML head -->
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NT8GYBTL15"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NT8GYBTL15');
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../styles/mdbook.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html">2020 新計劃</a></li><li class="chapter-item expanded "><a href="../GLOSSARY.html">Glossary</a></li><li class="chapter-item expanded "><a href="../sorting/index.html">排序 Sorting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sorting/bubble-sort.html">20/01/02 - 泡沫排序法</a></li><li class="chapter-item expanded "><a href="../sorting/cocktail-sort.html">20/01/03 - 雞尾酒排序法</a></li><li class="chapter-item expanded "><a href="../sorting/inversions.html">20/01/04 - 逆序數對</a></li><li class="chapter-item expanded "><a href="../sorting/merge-sort.html">20/01/05 - 合併排序法</a></li><li class="chapter-item expanded "><a href="../sorting/in-place-mergesort.html">20/01/06 - 原地演算法</a></li><li class="chapter-item expanded "><a href="../sorting/quick-sort.html">20/01/08 - 快速排序法</a></li><li class="chapter-item expanded "><a href="../sorting/randomized-quicksort.html">20/01/10 - 隨機快速排序法（一）</a></li><li class="chapter-item expanded "><a href="../sorting/randomized-quicksort2.html">20/01/12 - 隨機快速排序法（二）</a></li><li class="chapter-item expanded "><a href="../sorting/randomized-quicksort3.html">20/01/13 - 隨機快速排序法（三）</a></li><li class="chapter-item expanded "><a href="../sorting/heapsort.html">20/01/16 - 堆積排序法</a></li><li class="chapter-item expanded "><a href="../sorting/comparison-based-sorting.html">20/01/18 - 比較排序下界</a></li><li class="chapter-item expanded "><a href="../sorting/minimum-comparison-sort.html">20/01/20 - 最少比較排序</a></li><li class="chapter-item expanded "><a href="../sorting/merge-insertion-sort.html">20/01/22 - 合併插入排序</a></li><li class="chapter-item expanded "><a href="../sorting/poset-efficiency.html">20/01/25 - 偏序集排序（一）</a></li><li class="chapter-item expanded "><a href="../sorting/linear-extensions.html">20/01/26 - 偏序集排序（二）</a></li><li class="chapter-item expanded "><a href="../sorting/order-polytope-and-ehrhart-polynomial.html">20/01/27 - 偏序集排序（三）</a></li><li class="chapter-item expanded "><a href="../sorting/chain-polytope-and-graph-entropy.html">20/02/01 - 偏序集排序（四）</a></li><li class="chapter-item expanded "><a href="../sorting/poset-sort5.html">20/02/03 - 偏序集排序（五）</a></li><li class="chapter-item expanded "><a href="../sorting/poset-sort6.html">20/02/07 - 偏序集排序（六）</a></li><li class="chapter-item expanded "><a href="../sorting/poset-sort7.html">20/02/14 - 偏序集排序（七）</a></li><li class="chapter-item expanded "><a href="../sorting/poset-sort8.html">20/02/17 - 偏序集排序（八）</a></li><li class="chapter-item expanded "><a href="../sorting/poset-sort9.html">20/02/21 - 偏序集排序（九）</a></li><li class="chapter-item expanded "><a href="../sorting/shell-sort1.html">20/02/26 - 謝耳排序法（一）</a></li><li class="chapter-item expanded "><a href="../sorting/shell-sort2.html">20/02/28 - 謝耳排序法（二）</a></li><li class="chapter-item expanded "><a href="../sorting/shell-sort3.html">20/03/08 - 謝耳排序法（三）</a></li><li class="chapter-item expanded "><a href="../sorting/shell-sort4.html">20/10/12 - 謝耳排序法（四）</a></li><li class="chapter-item expanded "><a href="../sorting/sorting-network.html">21/01/03 - 排序網路</a></li><li class="chapter-item expanded "><a href="../sorting/sorting-network-correctness.html">21/01/04 - 驗證排序網路</a></li></ol></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/index.html">最小生成樹</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../minimum-spanning-tree/list.html">各式演算法</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/prims-mst.html">Prim's 演算法</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/kruskal-mst.html">Kruskal's 演算法</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/boruvka-mst.html">Borůvka's 演算法</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/boruvka-prim.html">Borůvka-Prim 演算法</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/yao-mst.html">Yao's 演算法</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/boruvka-steps-on-tree.html">Borůvka 樹分治（一）</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/boruvka-steps-on-tree2.html">Borůvka 樹分治（二）</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/mst-verification.html" class="active">驗證最小生成樹</a></li><li class="chapter-item expanded "><a href="../minimum-spanning-tree/karger-klein-tarjan.html">Karger-Klein-Tarjan 演算法</a></li></ol></li><li class="chapter-item expanded "><a href="../matching/index.html">圖匹配</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../matching/list.html">各式演算法</a></li></ol></li><li class="chapter-item expanded "><a href="../dynamic-graph/index.html">動態圖論資料結構</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dynamic-graph/connectivity/index.html">無向圖的連通問題 Connectivity</a></li><li class="chapter-item expanded "><a href="../dynamic-graph/reachability/index.html">有向圖的連通問題 Reachability</a></li></ol></li><li class="chapter-item expanded "><a href="../max-flow/index.html">最大網路流</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../max-flow/max-flow-min-cut-theorem.html">最大流最小割定理</a></li></ol></li><li class="chapter-item expanded "><a href="../mwu/index.html">乘法權重更新法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../mwu/fractiona-packing-problem.html">分數包裝問題</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">演算法的分析與證明</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="驗證最小生成樹-minimum-spanning-tree-verification"><a class="header" href="#驗證最小生成樹-minimum-spanning-tree-verification">驗證最小生成樹 Minimum Spanning Tree Verification</a></h1>
<p>我們知道給定一個圖，算出最小生成樹可能沒有那麼容易做到線性時間（我們甚至不知道是否能做到線性次數比較）。
如果反過來說，給定一個有權重的圖 \(G\) 以及一棵樹 \(T\)，我們有沒有辦法快速判斷樹 \(T\) 是最小生成樹呢？</p>
<h3 id="利用-tree-path-maximum-來解決"><a class="header" href="#利用-tree-path-maximum-來解決">利用 Tree Path Maximum 來解決</a></h3>
<p>這個問題其實可以藉由我們前一篇提及的「樹上路徑最大值問題」來解決：對於每一條不在樹上的邊 \((u, v)\)，我們只要詢問 \(T\) 上面這條連接 \(u\) 和 \(v\) 的路徑 \(u\leadsto v\) 上頭最重的一條邊，其權重是否大於 \((u, v)\) 這條邊的權重即可。</p>
<h3 id="一點小小的歷史"><a class="header" href="#一點小小的歷史">一點小小的歷史</a></h3>
<p>Komlós<sup class="footnote-reference"><a href="#1">1</a></sup> 在 1985 年率先證明出來，如果要驗證一棵樹是否為最小生成樹，存在一個演算法在最差情形下「只需要進行 \(O(m+n)\) 次兩數值比較」。
但是直到 1992 年，才由 Dixon、Rauch、以及 Tarjan<sup class="footnote-reference"><a href="#2">2</a></sup> 把這個想法實作出線性時間的演算法。
不過他們的縮樹演算法太複雜了，得預處理一大堆東西。緊接著 King<sup class="footnote-reference"><a href="#3">3</a></sup> 在 1995 年給出了一個稍微簡單一些的驗證最小生成樹演算法。
在若干年後 Hagerup<sup class="footnote-reference"><a href="#4">4</a></sup> 化簡了 King 的線性時間演算法，
為了表示其演算法的簡單程度，Hagerup 很自豪地在論文中提供了用 D 語言的程式碼。</p>
<p>我們現在就來看看 Hagerup 演算法到底是怎麼做到線性時間的吧！</p>
<h2 id="第一步borůvka-樹分治"><a class="header" href="#第一步borůvka-樹分治">第一步：Borůvka 樹分治</a></h2>
<p>首先，我們可以利用 King's 轉化，將整棵樹 \(T\) 轉化成一棵完滿分叉樹（Full Branching Tree）\(B\)。
此外，由於每一條不在樹上的邊，都會變成一個樹上路徑最大值的詢問，我們可以預先利用線性 \(O(m)\) 時間計算每個詢問兩端點的最小共同祖先 (LCA)，將所有樹上路徑詢問轉換成 \(O(m)\) 個『子孫、祖先』之間的路徑最大值詢問。</p>
<h2 id="第二步komlós-查詢"><a class="header" href="#第二步komlós-查詢">第二步：Komlós 查詢</a></h2>
<p>現在，對於這個完滿分叉樹 \(B\) 上面的每一個節點 \(v\)，我們可以預先知道有哪些詢問 \((u, v)\) 是以 \(v\) 作為子孫節點的。
我們令 \(Q_v\) 為所有以 \(v\) 為子孫節點的詢問 \((u, v)\) 所形成的集合。
令 \(A_v\) 為以 \(v\) 為根的子樹中，所有節點 \(x\) 中，\(Q_x\) 內祖先節點 \(u\) 所形成的集合。
換句話說
\[
A_v := \bigcup_{x\in T_v} \{u \ \vert \ (u, x)\in Q_x\}
\]
用白話來講的話，\(A_v\) 包含了進入 \(v\) 節點以後所有可能詢問到的祖先集合。
注意到這個集合大小至多是 \(\log n\) 的，因為 \(B\) 是一棵完滿分叉樹。
換句話說，如果我們能夠<strong>預先處理</strong>所有從 \(v\) 到 \(A_v\) 之間的路徑最大值，
並且將它們存放在一個雜湊陣列 \(\mathit{Stack}_v\) 中，
那麼對於每一個 \(Q_v\) 內部的詢問，我們都可以花常數時間查看這個陣列並取得答案。</p>
<h2 id="第三步單調堆疊"><a class="header" href="#第三步單調堆疊">第三步：單調堆疊</a></h2>
<p>為什麼我們會將該陣列命名為 \(\mathit{Stack}_v\) 呢？
因為它根本是一個單調堆疊 (monotonic stack) 的樣貌：
該陣列中，隨著查詢的祖先節點深度越淺、其答案（路徑最大值）也必定越大。</p>
<p>此外，假設我們從 \(v\) 走到其子節點 \(v'\)，那麼首先我們會有 \(A_{v'} \subseteq A_v\)。
對於陣列 \(\mathit{Stack}_v\) 中的 (祖先、路徑最大值) 組合，一定會從最深的點開始壓起。
因此從 \(\mathit{Stack}_v\) 到 \(\mathit{Stack}_{v'}\) 的過程，只是拿掉一些陣列中的元素、並且進行一次單調堆疊的插入而已。</p>
<p>但是進行單調堆疊的插入，會花費很多次比較。
Komlós 想到了一個辦法：既然 \(\mathit{Stack}_v\) 已經是個隨著深度越深、路徑最大值單調遞減的陣列了，那何不直接用二分搜尋呢？
Komlós 在 1985 年給出了一個超酷的定理，若你只在乎從每個點進行更新堆疊時，二分搜尋所花費的<strong>比較次數</strong>，那麼總比較次數是線性的：</p>
<h3 id="定理-mst18-komlós-1985"><a class="header" href="#定理-mst18-komlós-1985">定理 MST.18 [Komlós 1985]</a></h3>
<p>若 \(B\) 是一個完滿分叉樹，而且對於所有 \(v\in B\)。令 \(m=\sum_{v\in B} \vert Q_v\vert \) 且假設 \(|Q_v\vert \ge 1\)。那麼
\[
\sum_{v\in B} \log(\vert A_v\vert +1) = O(n\log\left( \frac{m+n}{n}\right)) = O(m+n)
\]</p>
<h3 id="證明-mst18-的歸納部分"><a class="header" href="#證明-mst18-的歸納部分">證明 MST.18 的歸納部分</a></h3>
<p>我們可以由下至上，逐層以數學歸納法證明：令某個固定高度 \(h\) 並考慮所有高度為 \(h\) 節點為樹根的子樹們叫做 \(\mathrm{Trees}(h)\)。
由數學歸納法的歸納假設我們可以知道，對於任何 \(T_w\in \mathrm{Trees}(h-1)\)，令 \(m_w = \sum_{x\in T_w}\vert Q_x\vert \) 且 \(n_w = \vert T_w\vert \)，那麼有 \(\sum_{x\in T_w} \log(\vert A_x\vert +1) \le  c_{h-1} n_w \log\left(\frac{m_w+n_w}{n_w}\right)\)，其中 \(c_{h-1}\) 是某個與 \(h\) 有關的參數。
現在對於每一個高度 \(h\) 節點為樹根的樹 \(T_v\in \mathrm{Trees}(h)\)，利用 \(\log\) 函數的凹性，依據延森不等式我們有</p>
<p>\[
\begin{aligned}
\sum_{x\in T_v}\log(\vert A_x\vert +1) &amp;= \log(\vert A_v\vert +1) + \sum_{w: v \textrm{ 的子節點}}\ \ \ \  \sum_{x\in T_w}\log(\vert A_x\vert +1) \\
&amp;\le \log(\vert A_v\vert +1) + \sum_{w: v \text{ 的子節點}}\ \ \ \  c_{h-1}n_w\log \left(\frac{m_w+n_w}{n_w}\right) \\
&amp;\le \log(m_v+1) + \sum_{w: v \text{ 的子節點}}\ \ \ \  \underbrace{c_{h-1}\log \left(\frac{m_w+n_w}{n_w}\right) + \cdots + c_{h-1}\log \left(\frac{m_w+n_w}{n_w}\right)}_{n_w\text{ 個}}\\
&amp;\le \log(m_v+n_v) + c_{h-1} n_v\log\left(\frac{m_v+n_v}{n_v}\right) \ \ \ (\text{延森不等式})\\
&amp;= \log\left[\left(\frac{m_v+n_v}{n_v}\right)^{c_{h-1}\ n_v}\left(\frac{m_v+n_v}{n_v}\right) n_v\right]\\
&amp;\le \log\left[\left(\frac{m_v+n_v}{n_v}\right)^{c_{h-1}\ n_v+1+\log_2n_v}\right]\ \ \ (\text{利用 } m_v\ge n_v \text{ 所以底數至少是 } 2)
\end{aligned}
\]</p>
<p>重點來啦～由於 \(B\) 是一個完滿分叉樹，因此我們知道高度是 \(h\) 的樹，其節點數量至少有 \(2^h-1\) 這麼多個。
因此，我們可以隨意估計：存在一個絕對的常數 \(\hat{c}\ge 100\)，使得對於所有的 \(h\)，皆有 \(1+\log_2 n_v \le \frac{\hat{c}}{h^2}n_v\)。
於是我們可以定義 \(c_h = \hat{c}(\frac{1}{1^2} + \frac{1}{2^2} + \cdots + \frac{1}{h^2}) = \Theta(1)\)，
這麼一來便有 \(c_{h-1}n_v + 1 + \log_2 n_v \le c_hn_v\)，滿足數學歸納法的要求，所以就得證啦。</p>
<h3 id="komlós-演算法"><a class="header" href="#komlós-演算法">Komlós 演算法</a></h3>
<p>有了以上重要的 Komlós 分析以後，我們便能輕易地得到一個「只需要 \(O(m+n)\) 次數值比較」的最小生成樹驗證演算法：</p>
<ul>
<li>第一次 DFS：找出每一個節點之 \(A_v\) 集合。</li>
<li>第二次 DFS：找出每一個節點之 \(\mathit{Stack}_v\) 陣列，並且順手回答所有 \(Q_v\) 的詢問。</li>
</ul>
<h2 id="第四步使用-bit-tricks-把其他部分變成常數時間操作"><a class="header" href="#第四步使用-bit-tricks-把其他部分變成常數時間操作">第四步：使用 Bit Tricks 把其他部分變成常數時間操作</a></h2>
<p>看到這邊，對於位元運算等操作熟稔的朋友們，應該已經可以喜孜孜地重現 Hagerup 的論文：將 Komlós 演算法用線性時間內實作出來～
由於 \(B\) 是完滿分叉樹，其深度保證是 \(O(\log n)\)，在 Word RAM 模型底下，我們總是能假設每一個位元組都有 \(O(\log n)\) 個位元。
因此每一個 \(A_v\) 集合我們可以用常數個 bit mask 來表示，而其他的操作也可以順手用 Bit Tricks / 預處理查表輕鬆搞定。</p>
<h3 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h3>
<ul>
<li>Valerie King 的投影片 <a href="http://www.cs.technion.ac.il/%7Eidddo/mstverif.pdf">http://www.cs.technion.ac.il/~idddo/mstverif.pdf</a></li>
<li>Uri Zwick 的授課筆記 <a href="http://www.cs.tau.ac.il/%7Ezwick/grad-algo-0910/mst-verify.pdf">http://www.cs.tau.ac.il/~zwick/grad-algo-0910/mst-verify.pdf</a></li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>János Komlós, <a href="https://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/linear.pdf">Linear Verification for Spanning Trees</a>, Combinatorica 1985.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Brandon Dixon, Monika Rauch, and Robert E. Tarjan, <a href="https://epubs.siam.org/doi/abs/10.1137/0221070?journalCode=smjcat">Verification and Sensitivity Analysis of Minimum Spanning Trees in Linear Time</a>, SIAM Journal of Computing, 1992.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Valerie King, <a href="https://www.cs.princeton.edu/courses/archive/fall03/cs528/handouts/A%20Simpler%20Minimum%20Spanning.pdf">A Simpler Minimum Spanning Tree Verification Algorithm</a>, Algorithmica, 1997. (WADS 1995)</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Torben Hagerup, <a href="https://link.springer.com/chapter/10.1007/978-3-642-11409-0_16">An Even Simpler Linear-Time Algorithm for Verifying Minimum Spanning Trees</a>, Graph Theoretic Concepts in Computer Science, 2009.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../minimum-spanning-tree/boruvka-steps-on-tree2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../minimum-spanning-tree/karger-klein-tarjan.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../minimum-spanning-tree/boruvka-steps-on-tree2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../minimum-spanning-tree/karger-klein-tarjan.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../mathjax-config.js"></script>


    </body>
</html>
